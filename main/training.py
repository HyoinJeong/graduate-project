# -*- coding: utf-8 -*-
"""Training.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Axy-BGMHp_mqS_CB_Q8ifzsiobAfyTfH
"""

import os
import glob
import librosa
import sklearn
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import random



import tensorflow as tf
import keras
import torch
from keras import layers, models ,Model ,Input
from keras.layers import Dense, Flatten, Activation, BatchNormalization
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split, KFold
from tensorflow.keras.utils import to_categorical
from keras.callbacks import EarlyStopping

torch.cuda.is_available()

from google.colab import drive
drive.mount('/content/gdrive', force_remount=True)

Train_Dir = '/content/gdrive/MyDrive/VoiceRecognition/data/Train/'
Test_Dir = '/content/gdrive/MyDrive/VoiceRecognition/data/Test/'

def MFCC(audio_path):
  path = audio_path
  sample_rate = 16000

  x = librosa.load(path,sample_rate)[0]
  S = librosa.feature.melspectrogram(x, sr=sample_rate, n_mels=128)
  log_S = librosa.power_to_db(S, ref=np.max)
  mfcc = librosa.feature.mfcc(S=log_S, n_mfcc=20)

  delta2_mfcc = librosa.feature.delta(mfcc, order=2)

  return mfcc, delta2_mfcc

def Mel_spec(audio_path):
  path = audio_path
  sample_rate = 16000

  x = librosa.load(path,sample_rate)[0]
  S = librosa.feature.melspectrogram(x, sr=sample_rate, n_mels=128)
  log_S = librosa.power_to_db(S, ref=np.max)

  return log_S

def padding(list,*array) :
 max = 0
 for i in range(len(list)):
    if max == 0 or list[i].shape[1] > max :
      max = list[i].shape[1]
 for i in range(len(list)):
   addnum = max - list[i].shape[1]
   list[i] = np.pad(list[i], [(0, 0), (0, addnum)], mode='constant')
 for i in array:
   for j in range(len(list)):
     if str(type(i)) == "<class 'numpy.ndarray'>" :
       addnum = i[0].shape[1] - list[j].shape[1]
       if addnum >= 0:
         list[j] = np.pad(list[j], [(0, 0), (0, addnum)], mode='constant')
       else :
         list[j] = list[j][:,0:i[0].shape[1]]


from sklearn.metrics import accuracy_score, precision_score, recall_score, confusion_matrix

def get_eval(test_y, pred):

  confusion = confusion_matrix(test_y, pred)
  accuracy = accuracy_score(test_y, pred)
  precision = precision_score(test_y, pred, average='macro')
  recall = recall_score(test_y, pred)
  print('Confusion Matrix')
  print(confusion)
  print('Accuracy:{}, Precision:{}, Recall:{}'.format(accuracy, precision, recall))

